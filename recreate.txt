Recreate loadlibrary
--------------------

Nothing to see here, everything just works as expected (although I can't find mpstreamfuzz...)

Recreate WindowsDefenderTools
-----------------------------

### MPENGINE offsets

"IMPORTANT: The offsets contained in this project are specific to the 6/25/2018 32-bit mpengine.dll build, MD5=e95d3f9e90ba3ccd1a4b8d63cbd88d1b. If you are using a different version of mpengine.dll, you'll need to locate these offsets yourself. It's easiest to wait for Microsoft to publish mpengine.dll PDBs with symbols, but it can be done easily without them."
        
    Offsets are in the .map file generated during loadlibrary setup?

No symbols as of 2018-09-04 (not even for older versions, symbol servers down) :(

DOESNTWORK (looking for old DLL's for which symbols are available): 
   MD5 -> Google
   Internet Archive (static MS link to latest definitions)
   Malware sites (Softpedia, etc)
   (I probably have the proper version on my other machine but...) 

README/Locating offsets:
    RVA_pe_read_string_ex @ +0x3EE353
    RVA_FP_OutputDebugStringA
        "Search for sequence of bytes 0B28014BB" -> 4.5 bytes, rly?
            Actually, BB 14 80 B2 (IDA swaps endianness if there are no spaces...)
        0x1b528 -> sub_1051BAE0
    RVA_Parameters1
        +0x4D07F5

### Left out parts

"Note that the included patches only contain my OutputDebugStringA hooking code. This will let you experiment with the engine and reproduce some of the demos I have shown. Implementing more advanced functionality demonstrated in my presentation is left as an exercise to the reader, eg: building a fuzzer, supporting format string-based output, dumping out arbitrary non-string buffers, hooking ExitProcess to understand when emulation is ending, or collecting coverage with a customized Lighthouse Pintool (https://github.com/gaasedelen/lighthouse)."
    => Slides: "~3k LoC added"

afl-pin
-------

PIN Tool needs to be cross-compiled to 32-bits (IA32). 

The PIN Tool can be built in DEBUG mode (`make -f makefile.pin debug`): Debug output to stderr, no shared memory bitmap (must be executed outside AFL).

Implemented BBL blacklist to speed things up
    Does it work? -> Not really: it's not much faster, and AFL doesn't recognize paths with missing BBLs

Based on DEBUG build results afl-pin's BBL tracing works after cross-compilation. This is also confirmed by ALFing different malware samples: AFL discovers 1-1 path for each sample, although it's not clear how these numbers can be efficiently increased...

Use the power of the fork server?
    set entry point where argv gets parsed first? How/when is argv populated?
    Created dummy test program (entrytest). It ran forever under AFL-Pin (when fuzzing, not when debugging) when functions other than _start was provided as forkserver entry point. Turns out that you must explicitly call exit() _in the function_ that you provided as entry point! 
	main()->bar() performance: 9.x -> 21.x test/sec!

    Moved __rsignal call to separate function, added exit()'s: 
	0.1 -> 0.4 test/sec


/home/b/projects/av-fuzz/WindowsDefenderTools-re/afl-pin/pin-3.6/pin -t /usr/local/lib/pintool/afl-pin.so -forkserver -entrypoint _start -alternative -- ./mpclient_taviso /tmp/input/eicar.com

afl-fuzz-pin.sh -i /tmp/input -o /tmp/output -forkserver -entrypoint _start -t 15000  -alternative  -- ./mpclient_taviso @@


### Dyninst

Dyninst has a 32-bit cross-compilation option for the runtime (RT), but not for libcommon...

afl-pin README: "forkserver is faster than afl-dyninst"

### Persistent mode

https://twitter.com/MShudrak/status/1055151103078105088

"I managed to achieve ~30-70 exec/s under Pin. If you instrument mpclient with afl-clang-fast++ and setup __AFL_LOOP(100000) right before *second* __rsignal you can significantly improve performance. Of course you still need to instrument mpengine.dll with Pin." (emphasis mine)

After the first __rsignal() call subsequent executions run much faster
    -> VDM's already loaded - this is confirmed by inotify:
		$ for i in `seq 1 5`; do inotifywatch -v -e access -t 15 *.vdm;done     
		Establishing watches...
		Total of 4 watches.
		Finished establishing watches, now collecting statistics.
		Will listen for events for 15 seconds.
		total  access  filename
		405    405     mpavbase.vdm
		262    262     mpasbase.vdm
		147    147     mpavdlta.vdm
		52     52      mpasdlta.vdm
		Establishing watches...
		Total of 4 watches.
		Finished establishing watches, now collecting statistics.
		Will listen for events for 15 seconds.
		No events occurred.
		Establishing watches...
		Total of 4 watches.
		Finished establishing watches, now collecting statistics.
		Will listen for events for 15 seconds.
		No events occurred.
		Establishing watches...
		Total of 4 watches.
		Finished establishing watches, now collecting statistics.
		Will listen for events for 15 seconds.
		No events occurred.
		Establishing watches...
		Total of 4 watches.
		Finished establishing watches, now collecting statistics.
		Will listen for events for 15 seconds.
		No events occurred.


fopen(filename) outside call_rsignal() fails (only) under AFL-Pin, only works with const dummy path
    why?

### Intel PT

#### honggfuzz 

honggfuzz supports PT out of the box
    libipt API change needs some patching: https://github.com/google/honggfuzz/issues/206#issuecomment-433627965

relies on ptrace() - debugger detection in mpclient needs to be disabled

trancing seems to be working, but supplying inputs persistent-style (without restarting the process) needs compilation with hfuzz-cc
    maybe manual patching of honggfuzz is easier? <<< TODO

using persistent mode (or even netdriver) is problematic because everything needs to be cross-compiled to 32-bit
    this includes libipt, libunwind and libbfd at least
        installing libunwind:i386 basically breaks the OS installation on ubuntu
    Most AV's are 32-bit only!
    
    could build everything in a 32-bit VM, but hypervisor support for PT is not great
        only supported in VMWare Workstation beta
        KVM status is unclear
        Xen may work, but I won't install that on my Skylake box for reasons...

    SOLUTION: Use a container like it's 2018 \o/
        Programs run natively, all CPU features are available
        Can build a 32-bit userland without messing with the host system

        PoC built on xenial (trusty has outdated libc headers)
        clang-6.0 from llvm repo

    `docker run --privileged ...` is needed to access HW perf counters.

    using the wrong feedback cmdline switch can make you spend hours figuring out why PT events are not recorded...

    HF_ITER style persistence is the simplest to implement in this case
        https://github.com/google/honggfuzz/blob/master/docs/PersistentFuzzing.md#hf_iter-style
    I waste resources by creating files for testcases, full in-memory can probably be implemented by modifying ReadStream(), GetStreamSize(), etc.
